<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drum Tuner (Web)</title>
  <style>
    :root{--bg:#0f172a;--fg:#e5e7eb;--muted:#94a3b8;--card:#111827;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;}
    body{margin:0;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";background:var(--bg);color:var(--fg);} 
    header{padding:16px 20px;background:#0b1220;border-bottom:1px solid #1f2937;}
    h1{font-size:20px;margin:0}
    main{max-width:980px;margin:0 auto;padding:20px;}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:16px;flex:1;min-width:280px;}
    .btn{background:#2563eb;border:none;color:white;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.stop{background:#ef4444}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .big{font-size:42px;font-weight:800}
    .mid{font-size:22px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;color:#cbd5e1;font-size:12px}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px}
    .lug{background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:10px;cursor:pointer;transition:all .15s}
    .lug:hover{border-color:#334155;transform:translateY(-1px)}
    .lug.selected{border-color:#60a5fa;box-shadow:0 0 0 2px rgba(96,165,250,.2) inset}
    .lug h4{margin:0 0 6px 0;font-size:14px;color:#cbd5e1}
    .lug .hz{font-weight:700;font-size:18px}
    .meter{height:10px;background:#0b1220;border:1px solid #1f2937;border-radius:999px;overflow:hidden}
    .bar{height:100%;background:linear-gradient(90deg,#ef4444,#f59e0b,#22c55e,#f59e0b,#ef4444)}
    canvas{width:100%;height:140px;background:#0b1220;border:1px solid #1f2937;border-radius:10px}
    label{display:block;margin-bottom:6px}
    input[type="number"], select{background:#0b1220;border:1px solid #1f2937;color:#e5e7eb;border-radius:10px;padding:8px;width:100%}
    .footer{opacity:.7;font-size:12px;margin-top:12px}
    .tests{font-size:12px;line-height:1.4}
    .pass{color:#22c55e}
    .fail{color:#ef4444}
  </style>
</head>
<body>
<header>
  <h1>Drum Tuner (開発中)　- Created by Haruto -</h1>
</header>
<main>
  <div class="row">
    <div class="card" style="flex:2">
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <button id="startBtn" class="btn">マイク開始</button>
        <button id="stopBtn" class="btn stop" disabled>マイク停止</button>
        <span class="pill" id="status">準備中</span>
      </div>
      <div class="row" style="margin-top:14px">
        <div class="card">
          <div class="muted">平均周波数</div>
          <div class="big mono" id="freq">--.- Hz</div>
          <div class="muted">信頼度: <span id="conf">--</span></div>
        </div>
        <div class="card">
          <div class="muted">音階（A4=440Hz）</div>
          <div class="big" id="note">--</div>
          <div class="mid muted">偏差 <span id="cents">--</span> cents</div>
        </div>
      </div>
      <div style="margin-top:12px">
        <canvas id="wave"></canvas>
      </div>
      <div style="margin-top:12px">
        <canvas id="spec"></canvas>
      </div>
    </div>
    <div class="card" style="flex:1">
      <label>ラグ本数
        <select id="lugCount">
          <option>6</option>
          <option selected>8</option>
          <option>10</option>
        </select>
      </label>
      <div style="display:flex;gap:8px;margin:8px 0 12px">
        <button id="saveLug" class="btn" disabled>このラグに保存</button>
        <button id="clearLugs" class="btn" disabled>全クリア</button>
      </div>
      <div class="grid" id="lugGrid"></div>
      <div style="margin-top:10px" class="muted">平均 <span id="avgHz">--</span> Hz / ばらつき(σ) <span id="stdHz">--</span> Hz</div>
      <div class="meter" style="margin-top:8px"><div id="evenBar" class="bar" style="width:0%"></div></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <details>
      <summary>設定 / 解析オプション / 使い方</summary>
      <div class="row" style="margin-top:10px">
        <div class="card">
          <label>ローカット（Hz）
            <input type="number" id="hpCut" value="60" min="0" step="10" />
          </label>
          <label>ハイカット（Hz）
            <input type="number" id="lpCut" value="1200" min="100" step="50" />
          </label>
          <label>平滑化（移動中央値サンプル数）
            <input type="number" id="smoothN" value="5" min="1" max="21" step="2" />
          </label>
        </div>
        <div class="card">
          <div class="muted">使い方</div>
          <ol>
            <li>「<b>マイク開始</b>」をクリックしてマイク入力を許可してください。</li>
            <li>各ラグ近くを順番に叩いてください。</li>
            <li>1打ごとに自動解析をします。十分な信頼度が得られた結果のみ保存できます。</li>
            <li>保存したいラグを選択し、「<b>このラグに保存</b>」をクリックしてください。</li>
            <li>チューニングが終了したら、「<b>マイク停止</b>」をクリックしてください。</li>
          </ol>
          <div class="muted">注意：平均周波数はヘッド/胴/共鳴/周囲の環境の影響を強く受けます。信頼度が低い場合は、叩く位置や周囲の環境を変えて、再度チューニングを試してください。</div>
        </div>
      </div>
    </details>
  </div>

  <div class="card" style="margin-top:16px">
    <div class="muted">Diagnostics / Self‑tests（ページ読み込み時に自動実行）</div>
    <ul id="tests" class="tests"></ul>
  </div>
</main>
<script>
// ==============================================
// Drum Tuner (Web) — robust start/stop, HTTPS check, AudioContext.resume, confidence gate, short-hit STFT
// ==============================================

// ---- Utilities ----
function isSecureContextOk(){
  const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  return location.protocol === 'https:' || isLocal;
}

function freqToNoteData(freq){
  if(!isFinite(freq) || freq<=0) return {note:"--", cents:"--"};
  const A4=440; const n = 12*Math.log2(freq/A4); const rounded = Math.round(n); const cents = Math.round((n - rounded)*100);
  const noteIndex=(rounded+69)%12; const octave=Math.floor((rounded+69)/12);
  const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  return {note:`${names[noteIndex]}${octave}`, cents:cents};
}
class MedianSmoother{constructor(size=3){this.size=size;this.buf=[]} push(x){if(!isFinite(x)) return x;this.buf.push(x); if(this.buf.length>this.size) this.buf.shift(); const s=[...this.buf].sort((a,b)=>a-b); return s[Math.floor(s.length/2)];}}

// ---- Minimal FFT ----
class FFT{ constructor(N){ this.N=N; this.rev=new Uint32Array(N); this.cos=new Float64Array(N/2); this.sin=new Float64Array(N/2); let j=0; for(let i=0;i<N;i++){ this.rev[i]=j; let bit=N>>1; while(j & bit){ j^=bit; bit>>=1;} j|=bit; } for(let k=0;k<N/2;k++){ const ang=-2*Math.PI*k/N; this.cos[k]=Math.cos(ang); this.sin[k]=Math.sin(ang);} } transform(re, im){ const N=this.N; const rev=this.rev; const cos=this.cos; const sin=this.sin; for(let i=0;i<N;i++){ const j=rev[i]; if(i<j){ const tr=re[i]; re[i]=re[j]; re[j]=tr; const ti=im[i]; im[i]=im[j]; im[j]=ti; } } for(let len=2; len<=N; len<<=1){ const half=len>>1; const step=N/len; for(let i=0;i<N;i+=len){ let k=0; for(let j=i;j<i+half;j++){ const c=cos[k], s=sin[k]; const tr=c*re[j+half]-s*im[j+half]; const ti=s*re[j+half]+c*im[j+half]; re[j+half]=re[j]-tr; im[j+half]=im[j]-ti; re[j]+=tr; im[j]+=ti; k+=step; } } } } }

// ---- DOM ----
const waveCanvas=document.getElementById('wave');
const specCanvas=document.getElementById('spec');
const wctx=waveCanvas.getContext('2d');
const sctx=specCanvas.getContext('2d');
const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
const statusEl=document.getElementById('status');
const freqEl=document.getElementById('freq');
const confEl=document.getElementById('conf');
const noteEl=document.getElementById('note');
const centsEl=document.getElementById('cents');
const hpCut=document.getElementById('hpCut');
const lpCut=document.getElementById('lpCut');
const smoothN=document.getElementById('smoothN');
const lugCountSel=document.getElementById('lugCount');
const lugGrid=document.getElementById('lugGrid');
const saveLug=document.getElementById('saveLug');
const clearLugs=document.getElementById('clearLugs');
const avgHz=document.getElementById('avgHz');
const stdHz=document.getElementById('stdHz');
const evenBar=document.getElementById('evenBar');

function setRunState(running){
  if(running){ startBtn.disabled=true; stopBtn.disabled=false; }
  else { startBtn.disabled=false; stopBtn.disabled=true; }
}
setRunState(false);

// ---- State ----
let audioCtx, analyser, source, scriptNode, mediaStream; 
let lastFreq=0; let lastConf=0; let allowSave=false; let smoother=new MedianSmoother(3);
let lugCount=8; let lugHz=Array(lugCount).fill(null);
let selectedLug=0; // 0-indexed

// ---- Ring buffer ----
let sampleRate=48000; const RING_SEC=4; let RING_SIZE=RING_SEC*sampleRate; let ring=new Float32Array(RING_SIZE); let ringPos=0; let totalSamples=0;

// ---- Onset/offset ----
let env=0, envLP=0.005;
const ONSET_THR=0.04;     // normalized envelope threshold
const OFFSET_THR=0.010;   // lower to catch very short tails
const MIN_HIT_MS=15;      // allow very short hits (~15ms)
const QUIET_MS_AFTER=15;  // faster tail confirm
const CONF_MIN=0.90;      // require >= 90% confidence
let inHit=false; let hitStart=-1; let lastAbove=0; let hitEnd=-1;

// ---- Drawing ----
function drawWave(timeData){ const W=waveCanvas.width=waveCanvas.clientWidth; const H=waveCanvas.height=waveCanvas.clientHeight; wctx.clearRect(0,0,W,H); wctx.lineWidth=2; wctx.beginPath(); const N=timeData.length; for(let i=0;i<N;i++){ const x=i/N*W; const y=(0.5- timeData[i]/2)*H; if(i===0) wctx.moveTo(x,y); else wctx.lineTo(x,y);} wctx.strokeStyle='#93c5fd'; wctx.stroke(); }
function drawSpectrum(freqData){ const W=specCanvas.width=specCanvas.clientWidth; const H=specCanvas.clientHeight; sctx.clearRect(0,0,W,H); sctx.fillStyle='#60a5fa'; const N=freqData.length; for(let i=0;i<N;i++){ const x=i/N*W; const v=freqData[i]/255; const h=v*H; sctx.fillRect(x, H-h, W/N, h);} }

// ---- Audio start/stop ----
async function startAudio(){
  if(!isSecureContextOk()){
    statusEl.textContent='HTTPSで開いてください（localhostは可）。マイクAPIは非HTTPSでは動作しません。';
    return;
  }
  try{
    setRunState(true);
    statusEl.textContent='デバイス要求中…';
    mediaStream=await navigator.mediaDevices.getUserMedia({
      audio:{
        echoCancellation:{ideal:false},
        noiseSuppression:{ideal:false},
        autoGainControl:{ideal:false}
      }
    });
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    await audioCtx.resume();
    sampleRate=audioCtx.sampleRate; RING_SIZE=(RING_SEC*sampleRate)|0; ring=new Float32Array(RING_SIZE); ringPos=0; totalSamples=0; allowSave=false; lastFreq=0; lastConf=0; inHit=false;

    source=audioCtx.createMediaStreamSource(mediaStream);
    analyser=audioCtx.createAnalyser(); analyser.fftSize=2048; const bufferLen=2048; const timeData=new Float32Array(bufferLen); const byteFreq=new Uint8Array(analyser.frequencyBinCount);
    scriptNode=audioCtx.createScriptProcessor(2048,1,1);
    source.connect(analyser); analyser.connect(scriptNode); scriptNode.connect(audioCtx.destination);

    statusEl.textContent='計測待ち（打音検出）';
    // ボタン初期状態
    saveLug.disabled=true; clearLugs.disabled=false;

    scriptNode.onaudioprocess=(e)=>{ const ch=e.inputBuffer.getChannelData(0);
      for(let i=0;i<ch.length;i++){
        const x=ch[i]; ring[ringPos]=x; ringPos=(ringPos+1)%RING_SIZE; totalSamples++;
        env = (1-envLP)*env + envLP*Math.abs(x);
        const isLoud = env>ONSET_THR;
        if(!inHit && isLoud){ inHit=true; hitStart=totalSamples; lastAbove=totalSamples; statusEl.textContent='ヒット検出: 解析中…'; }
        if(inHit){ if(isLoud) lastAbove=totalSamples; const dtMs=(totalSamples-lastAbove)/sampleRate*1000; if(dtMs>QUIET_MS_AFTER && env<OFFSET_THR){ hitEnd=lastAbove; const durMs=(hitEnd-hitStart)/sampleRate*1000; inHit=false; if(durMs>MIN_HIT_MS){ analyzeHit(hitStart, hitEnd).then(({freq,conf})=>{ updateReadout(freq, conf); }).catch(err=>{ console.error(err); statusEl.textContent='解析エラー'; }); } else { statusEl.textContent='超短音のため解析に十分な長さがありませんでした（もう一度軽く叩いてください）'; } }
        }
      }
      analyser.getFloatTimeDomainData(timeData); drawWave(timeData); analyser.getByteFrequencyData(byteFreq); drawSpectrum(byteFreq);
    };
  }catch(err){
    console.error(err);
    statusEl.textContent='マイク開始に失敗：'+ (err && err.name ? err.name : '不明錯誤');
    stopAudio();
  }
}

function stopAudio(){
  try{
    if(scriptNode){ scriptNode.disconnect(); scriptNode.onaudioprocess=null; scriptNode=null; }
    if(analyser){ analyser.disconnect(); analyser=null; }
    if(source){ source.disconnect(); source=null; }
    if(audioCtx){ try{ audioCtx.suspend && audioCtx.suspend(); }catch(e){} try{ audioCtx.close(); }catch(e){} audioCtx=null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }catch(e){ console.warn('stop error', e); }
  setRunState(false);
  // 保存可否は最後に受理した結果に従う（allowSave）
  saveLug.disabled = !allowSave;
  statusEl.textContent='停止中';
}

startBtn.addEventListener('click', startAudio);
stopBtn.addEventListener('click', stopAudio);

function updateReadout(freq, conf){
  if(!(isFinite(freq)&&freq>0)) { saveLug.disabled=true; return; }
  if(conf < CONF_MIN){
    statusEl.textContent='信頼度が低いため、もう一度やり直してください（信頼度目安: 90%以上）';
    confEl.textContent = `${Math.round(conf*100)}%`;
    allowSave=false; saveLug.disabled=true; return;
  }
  lastFreq=freq; lastConf=conf; allowSave=true; saveLug.disabled=false;
  freqEl.textContent = `${freq.toFixed(1)} Hz`;
  confEl.textContent = `${Math.round(conf*100)}%`;
  const nd=freqToNoteData(freq); noteEl.textContent=nd.note; centsEl.textContent=nd.cents;
  statusEl.textContent='結果更新（次の打音待ち）';
}

// ---- Analyze one hit ----
async function analyzeHit(startSample, endSample){
  const N=endSample-startSample; if(N<128) return {freq:0, conf:0};
  const buf=new Float32Array(N); for(let i=0;i<N;i++){ const idx=(startSample+i)%RING_SIZE; buf[i]=ring[idx]; }
  // steady region
  const dropHead = Math.floor(N*0.05); const dropTail=Math.floor(N*0.10);
  let s0=dropHead, s1=N-dropTail; if(s1-s0<256){ s0=0; s1=N; }
  const steady=buf.subarray(s0, s1);

  const hp=Number(hpCut.value)||60; const lp=Number(lpCut.value)||1200;
  const frame=512; const hop=128; const fft=new FFT(frame);
  const hann=new Float32Array(frame); for(let i=0;i<frame;i++){ hann[i]=0.5*(1-Math.cos(2*Math.PI*i/(frame-1))); }
  let padded=steady; if(steady.length<frame){ padded=new Float32Array(frame); padded.set(steady); }

  const frames=[]; const binHz=sampleRate/frame; const loBin=Math.max(1, Math.floor(hp/binHz)); const hiBin=Math.min(frame/2-1, Math.ceil(lp/binHz));
  for(let off=0; off+frame<=padded.length; off+=hop){
    const x=padded.subarray(off, off+frame);
    const re=new Float64Array(frame); const im=new Float64Array(frame);
    let mean=0; for(let i=0;i<frame;i++){ mean+=x[i]; } mean/=frame; for(let i=0;i<frame;i++){ re[i]=(x[i]-mean)*hann[i]; im[i]=0; }
    fft.transform(re, im);
    const mags=new Float64Array(frame/2);
    for(let k=loBin;k<=hiBin;k++){ const a=re[k], b=im[k]; mags[k]=Math.hypot(a,b); }
    let pkBin=loBin, pkMag=0; for(let k=loBin;k<=hiBin;k++){ if(mags[k]>pkMag){ pkMag=mags[k]; pkBin=k; } }
    let fPeak = pkBin*binHz; if(pkBin>loBin && pkBin<hiBin){ const m1=mags[pkBin-1], m2=mags[pkBin], m3=mags[pkBin+1]; const denom=(m1-2*m2+m3); const delta = denom!==0 ? 0.5*(m1-m3)/denom : 0; fPeak=(pkBin+delta)*binHz; }
    const span=8; const k0=Math.max(loBin, pkBin-span), k1=Math.min(hiBin, pkBin+span); let num=0, den=0; for(let k=k0;k<=k1;k++){ const f=k*binHz; const w=mags[k]; num+=f*w; den+=w; }
    const fCentroid = den>0 ? num/den : fPeak;
    const alpha=0.7; const fEst=alpha*fPeak + (1-alpha)*fCentroid; frames.push(fEst);
  }
  if(frames.length===0) return {freq:0, conf:0};
  frames.sort((a,b)=>a-b); const cut=Math.max(0, Math.floor(frames.length*0.2)); const core=frames.slice(cut, frames.length-cut); const mean=core.reduce((a,b)=>a+b,0)/core.length; 
  const mu=mean; const sd=Math.sqrt(core.reduce((a,b)=>a+(b-mu)**2,0)/core.length); const conf = 1/ (1+ sd/ mu );
  return {freq:mean, conf:Math.max(0, Math.min(1, conf))};
}

// ---- Lugs ----
function renderLugs(){
  lugGrid.innerHTML='';
  for(let i=0;i<lugCount;i++){
    const v=lugHz[i];
    const div=document.createElement('div');
    div.className='lug'+(i===selectedLug?' selected':'');
    div.innerHTML=`<h4>ラグ ${i+1}</h4><div class="hz mono">${v? v.toFixed(1)+' Hz' : '--'}</div>`;
    div.addEventListener('click', ()=>{ selectedLug=i; renderLugs(); });
    lugGrid.appendChild(div);
  }
  const vals=lugHz.filter(v=>typeof v==='number');
  if(vals.length){
    const mean=vals.reduce((a,b)=>a+b,0)/vals.length;
    const variance=vals.reduce((a,b)=>a+(b-mean)**2,0)/vals.length; const sd=Math.sqrt(variance);
    avgHz.textContent=mean.toFixed(1); stdHz.textContent=sd.toFixed(1);
    const pct=Math.max(0, Math.min(100, (1 - Math.min(sd,15)/15)*100));
    evenBar.style.width=pct+'%';
  }else{ avgHz.textContent='--'; stdHz.textContent='--'; evenBar.style.width='0%'; }
}
renderLugs();

lugCountSel.addEventListener('change', ()=>{
  lugCount=Number(lugCountSel.value);
  selectedLug=Math.min(selectedLug, lugCount-1);
  lugHz=Array(lugCount).fill(null);
  renderLugs();
});

saveLug.addEventListener('click', ()=>{
  if(!allowSave){ statusEl.textContent='信頼度が低いため保存できません。もう一度やり直してください。'; return; }
  const idx=selectedLug;
  if(isFinite(lastFreq) && lastFreq>0){ lugHz[idx]=lastFreq; renderLugs(); }
});

clearLugs.addEventListener('click', ()=>{ lugHz=Array(lugCount).fill(null); renderLugs(); });

// ---- Self-tests ----
(function runTests(){
  const ul=document.getElementById('tests');
  function add(name, ok, info=''){
    const li=document.createElement('li');
    li.innerHTML=`<span class="${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</span> — ${name} ${info?(' <span class="muted">'+info+'</span>'):''}`;
    ul.appendChild(li);
  }
  try{
    // Test 1: DOM elements present
    add('DOM: startBtn exists', !!document.getElementById('startBtn'));
    add('DOM: stopBtn exists', !!document.getElementById('stopBtn'));
    add('DOM: saveLug exists', !!document.getElementById('saveLug'));

    // Test 2: setRunState toggles without error
    let ok=true; try{ setRunState(true); setRunState(false); ok=true; }catch(e){ ok=false; }
    add('UI: setRunState does not throw', ok);

    // Test 3: freqToNoteData(A4=440Hz)
    const n=freqToNoteData(440).note; add('Pitch map: 440Hz → A4', n==='A4', `got ${n}`);

    // Test 4: FFT peak check on pure sine (220Hz)
    const rate=44100, f=220, N=1024; const re=new Float64Array(N); const im=new Float64Array(N);
    for(let i=0;i<N;i++){ re[i]=Math.sin(2*Math.PI*f*i/rate); im[i]=0; }
    const fft=new FFT(N); fft.transform(re,im);
    let idx=0, mag=0; for(let k=1;k<N/2;k++){ const m=Math.hypot(re[k],im[k]); if(m>mag){mag=m; idx=k;} }
    const freq=idx*rate/N; add('FFT: 220Hz sine peak near 220Hz', Math.abs(freq-220)<10, `got ${freq.toFixed(1)}Hz`);

    // Test 5: HTTPS check message (does not assert true/false, only shows state)
    add('Env: secure context or localhost', isSecureContextOk(), location.protocol+"//"+location.host);

    // Test 6: Confidence gate enables save
    saveLug.disabled=true; allowSave=false; updateReadout(220, 0.95);
    add('Gate: saveLug enabled when conf >= 90%', !saveLug.disabled);

    // Test 7: Low confidence keeps save disabled
    saveLug.disabled=false; allowSave=true; updateReadout(220, 0.5);
    add('Gate: saveLug disabled when conf < 90%', saveLug.disabled);

    // Test 8: Lug click selects different card
    renderLugs();
    const before=document.querySelector('.lug.selected');
    const all=document.querySelectorAll('.lug');
    if(all.length>1){ all[1].click(); }
    const after=document.querySelector('.lug.selected');
    add('Lug: click changes selection', before!==after);
  }catch(e){ add('Self-test harness threw', false, e.message||String(e)); }
})();
</script>
</body>
</html>
