<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drum Tuner Ver.3 (開発中)　- Created by Haruto -</title>
  <style>
    :root{--bg:#0f172a;--fg:#e5e7eb;--muted:#94a3b8;--card:#111827;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;}
    body{margin:0;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";background:var(--bg);color:var(--fg);} 
    header{padding:16px 20px;background:#0b1220;border-bottom:1px solid #1f2937;}
    h1{font-size:20px;margin:0}
    main{max-width:980px;margin:0 auto;padding:20px;}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:16px;flex:1;min-width:280px;}
    .btn{background:#2563eb;border:none;color:white;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.stop{background:#ef4444}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .big{font-size:42px;font-weight:800}
    .mid{font-size:22px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;color:#cbd5e1;font-size:12px}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px}
    .lug{background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:10px;cursor:pointer;transition:all .15s}
    .lug:hover{border-color:#334155;transform:translateY(-1px)}
    .lug.selected{border-color:#60a5fa;box-shadow:0 0 0 2px rgba(96,165,250,.2) inset}
    .lug h4{margin:0 0 6px 0;font-size:14px;color:#cbd5e1}
    .lug .hz{font-weight:700;font-size:18px}
    .meter{height:10px;background:#0b1220;border:1px solid #1f2937;border-radius:999px;overflow:hidden}
    .bar{height:100%;background:linear-gradient(90deg,#1e40af,#93c5fd)}
    canvas{width:100%;height:140px;background:#0b1220;border:1px solid #1f2937;border-radius:10px}
    label{display:block;margin-bottom:6px}
    input[type="number"], select, input[type="range"]{background:#0b1220;border:1px solid #1f2937;color:#e5e7eb;border-radius:10px;padding:8px;width:100%}
    .footer{opacity:.7;font-size:12px;margin-top:12px}
    .tests{font-size:12px;line-height:1.4}
    .pass{color:#22c55e}
    .fail{color:#ef4444}
  </style>
</head>
<body>
<header>
  <h1>Drum Tuner Ver.3 (開発中)　- Created by Haruto -</h1>
</header>
<main>
  <div class="row">
    <div class="card" style="flex:2">
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <button id="startBtn" class="btn">マイク開始</button>
        <button id="stopBtn" class="btn stop" disabled>マイク停止</button>
        <span class="pill" id="status">準備中</span>
      </div>
      <div class="row" style="margin-top:14px">
        <div class="card">
          <div class="muted">推定周波数</div>
          <div class="big mono" id="freq">--.- Hz</div>
          <div class="muted">信頼度: <span id="conf">--</span></div>
        </div>
        <div class="card">
          <div class="muted">音階（A4=440Hz）</div>
          <div class="big" id="note">--</div>
          <div class="mid muted">偏差 <span id="cents">--</span> cents</div>
        </div>
      </div>
      <div style="margin-top:12px">
        <canvas id="wave"></canvas>
      </div>
      <div style="margin-top:12px">
        <canvas id="spec"></canvas>
      </div>
    </div>
    <div class="card" style="flex:1">
      <label>ラグ本数
        <select id="lugCount">
          <option>6</option>
          <option selected>8</option>
          <option>10</option>
        </select>
      </label>
      <div style="display:flex;gap:8px;margin:8px 0 12px">
        <button id="saveLug" class="btn" disabled>このラグに保存</button>
        <button id="clearLugs" class="btn">全クリア</button>
      </div>
      <div class="grid" id="lugGrid"></div>
      <div style="margin-top:10px" class="muted">平均 <span id="avgHz">--</span> Hz / ばらつき(σ) <span id="stdHz">--</span> Hz</div>
      <div class="meter" style="margin-top:8px"><div id="evenBar" class="bar" style="width:0%"></div></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <details>
      <summary>設定 / 解析オプション / 使い方</summary>
      <div class="row" style="margin-top:10px">
        <div class="card">
          <label>ローカット（Hz）
            <input type="number" id="hpCut" value="60" min="0" step="10" />
          </label>
          <label>ハイカット（Hz）
            <input type="number" id="lpCut" value="1200" min="100" step="50" />
          </label>
          <label>平滑化（移動中央値サンプル数）
            <input type="number" id="smoothN" value="5" min="1" max="21" step="2" />
          </label>
          <label>入力ゲイン（dB）
            <input type="range" id="gainDb" min="-12" max="24" step="1" value="0" />
            <span id="gainDbVal" class="muted">0 dB</span>
          </label>
          <label>バンドパス中心周波数（Hz）
            <input type="number" id="bpFreq" value="300" min="50" max="4000" step="10" />
          </label>
          <label>バンドパスQ
            <input type="number" id="bpQ" value="0.707" min="0.1" max="20" step="0.1" />
          </label>
        </div>
        <div class="card">
          <div class="muted">使い方</div>
          <ol>
            <li>「<b>マイク開始</b>」をクリックしてマイク入力を許可してください。</li>
            <li>各ラグ近くを順番に叩いてください。</li>
            <li>1打ごとに自動解析をします。十分な信頼度が得られた結果のみ保存が可能です。</li>
            <li>保存したいラグを選択し、「<b>このラグに保存</b>」をクリックしてください。</li>
            <li>チューニングが終了したら、「<b>マイク停止</b>」をクリックしてください。</li>
          </ol>
          <div class="muted">注意：推定周波数測定は「倍音/共鳴/周囲の環境」の影響を受けます。信頼度が低い場合は、叩く位置や周囲の環境を変えて、再度チューニングを試してください。</div>
        </div>
      </div>
    </details>
  </div>

  <div class="card" style="margin-top:16px">
    <div class="muted">Diagnostics / Self‑tests（ページ読み込み時に自動実行）</div>
    <ul id="tests" class="tests"></ul>
  </div>
</main>
<script>
// ==============================================
// Drum Tuner — AudioWorklet-based hit segmentation, band-pass prefilter, soft gain, robust smoothing
// ==============================================

// ---- Utilities ----
// [NEW] Quinn/Macleod sub-bin interpolation (log-magnitude)
function quinnDeltaFromMags(mags, k){
  const a1 = Math.max(1e-12, mags[k-1]);
  const a2 = Math.max(1e-12, mags[k]);
  const a3 = Math.max(1e-12, mags[k+1]);
  const Lm1 = Math.log(a1), L0 = Math.log(a2), Lp1 = Math.log(a3);
  const d1 = Lp1 - Lm1;
  const d2 = 2*L0 - (Lm1 + Lp1);
  const delta = (d2 !== 0) ? 0.5 * d1 / d2 : 0;
  return Math.max(-0.5, Math.min(0.5, delta));
}

// [NEW] YIN pitch estimator (returns {freq, conf})
function yinPitch(x, sr, fmin=50, fmax=1200){
  const N = x.length|0; if(N < 128) return {freq:0, conf:0};
  const tauMin = Math.max(2, Math.floor(sr/Math.max(fmax,1)));
  const tauMax = Math.min(N-2, Math.floor(sr/Math.max(fmin,1)));
  const d = new Float64Array(tauMax+1);
  for(let tau=tauMin; tau<=tauMax; tau++){
    let sum=0; for(let i=0;i+tau<N;i++){ const diff=x[i]-x[i+tau]; sum += diff*diff; }
    d[tau]=sum;
  }
  const cmnd = new Float64Array(tauMax+1);
  let run=0;
  for(let tau=tauMin; tau<=tauMax; tau++){ run += d[tau]; cmnd[tau] = (run>0) ? d[tau]*tau/run : 1; }
  const TH=0.1; let tauBest=-1;
  for(let tau=tauMin+1; tau<=tauMax-1; tau++){
    if(cmnd[tau] < TH && cmnd[tau] <= cmnd[tau+1]) { tauBest=tau; break; }
  }
  if(tauBest<0){ let m=1e9, idx=tauMin; for(let tau=tauMin; tau<=tauMax; tau++){ if(cmnd[tau]<m){ m=cmnd[tau]; idx=tau; } } tauBest=idx; }
  let tauEst=tauBest;
  if(tauBest>tauMin && tauBest<tauMax){
    const c1=cmnd[tauBest-1], c2=cmnd[tauBest], c3=cmnd[tauBest+1];
    const denom = (c1 + c3 - 2*c2);
    const dlt = denom!==0 ? 0.5*(c1 - c3)/denom : 0;
    tauEst = tauBest + Math.max(-0.5, Math.min(0.5, dlt));
  }
  const freq = sr / tauEst;
  const conf = Math.max(0, Math.min(1, 1 - cmnd[tauBest]));
  return {freq, conf};
}

// [NEW] 1D Kalman filter for Hz smoothing
class Kalman1D{ constructor(q=2.0, r=20.0){ this.q=q; this.r=r; this.x=null; this.p=1; } reset(){ this.x=null; this.p=1; } update(z, rOverride){ const r=(rOverride!=null)? rOverride : this.r; if(this.x==null){ this.x=z; this.p=1; return this.x; } this.p+=this.q; const K=this.p/(this.p+r); this.x=this.x+K*(z-this.x); this.p=(1-K)*this.p; return this.x; } }
let _kalman = new Kalman1D(2.0, 20.0);
function kalmanUpdateHz(hz, conf){ const r = Math.max(1, (1 - Math.max(0, Math.min(1, conf)) + 1e-3)*50); return _kalman.update(hz, r); }

// [NEW] 440Hz calibration (cents bias via localStorage)
const CAL_KEY='dt_cal_cents';
function getCalCents(){ const v=Number(localStorage.getItem(CAL_KEY)); return isFinite(v)? v: 0; }
function setCalCents(c){ try{ localStorage.setItem(CAL_KEY, String(Math.round(c))); }catch(_){} }
window.tunerGetCalCents = getCalCents; window.tunerSetCalCents = setCalCents; window.tunerCalibrateFromCurrent = function(){ const nd = freqToNoteData(lastFreq||0); if(Number.isFinite(nd.cents)) setCalCents(nd.cents); };
function isSecureContextOk(){
  const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  return location.protocol === 'https:' || isLocal;
}

function freqToNoteData(freq){
  if(!isFinite(freq) || freq<=0) return {note:"--", cents:"--"};
  const A4=440; const n = 12*Math.log2(freq/A4); const rounded = Math.round(n); const cents = Math.round((n - rounded)*100);
  const midi = 69 + rounded; const noteIndex = midi % 12; const octave = Math.floor(midi/12) - 1;
  const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  return {note:`${names[noteIndex]}${octave}`, cents:cents};
}
class MedianSmoother{constructor(size=3){this.size=size;this.buf=[]} push(x){if(!isFinite(x)) return x;this.buf.push(x); if(this.buf.length>this.size) this.buf.shift(); const s=[...this.buf].sort((a,b)=>a-b); return s[Math.floor(s.length/2)];}}

// ---- Minimal FFT ----
class FFT{ constructor(N){ this.N=N; this.rev=new Uint32Array(N); this.cos=new Float64Array(N/2); this.sin=new Float64Array(N/2); let j=0; for(let i=0;i<N;i++){ this.rev[i]=j; let bit=N>>1; while(j & bit){ j^=bit; bit>>=1;} j|=bit; } for(let k=0;k<N/2;k++){ const ang=-2*Math.PI*k/N; this.cos[k]=Math.cos(ang); this.sin[k]=Math.sin(ang);} } transform(re, im){ const N=this.N; const rev=this.rev; const cos=this.cos; const sin=this.sin; for(let i=0;i<N;i++){ const j=rev[i]; if(i<j){ const tr=re[i]; re[i]=re[j]; re[j]=tr; const ti=im[i]; im[i]=im[j]; im[j]=ti; } } for(let len=2; len<=N; len<<=1){ const half=len>>1; const step=N/len; for(let i=0;i<N;i+=len){ let k=0; for(let j=i;j<i+half;j++){ const c=cos[k], s=sin[k]; const tr=c*re[j+half]-s*im[j+half]; const ti=s*re[j+half]+c*im[j+half]; re[j+half]=re[j]-tr; im[j+half]=im[j]-ti; re[j]+=tr; im[j]+=ti; k+=step; } } } } }

// ---- DOM ----
const waveCanvas=document.getElementById('wave');
const specCanvas=document.getElementById('spec');
const wctx=waveCanvas.getContext('2d');
const sctx=specCanvas.getContext('2d');
const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
const statusEl=document.getElementById('status');
const freqEl=document.getElementById('freq');
const confEl=document.getElementById('conf');
const noteEl=document.getElementById('note');
const centsEl=document.getElementById('cents');
const hpCut=document.getElementById('hpCut');
const lpCut=document.getElementById('lpCut');
const smoothN=document.getElementById('smoothN');
const gainDb=document.getElementById('gainDb');
const gainDbVal=document.getElementById('gainDbVal');
const bpFreq=document.getElementById('bpFreq');
const bpQ=document.getElementById('bpQ');
const lugCountSel=document.getElementById('lugCount');
const lugGrid=document.getElementById('lugGrid');
const saveLug=document.getElementById('saveLug');
const clearLugs=document.getElementById('clearLugs');
const avgHz=document.getElementById('avgHz');
const stdHz=document.getElementById('stdHz');
const evenBar=document.getElementById('evenBar');

function setRunState(running){
  if(running){ startBtn.disabled=true; stopBtn.disabled=false; }
  else { startBtn.disabled=false; stopBtn.disabled=true; }
}
setRunState(false);

// ---- State ----
let audioCtx, analyser, source, mediaStream; 
let bandpass, softGain, workletNode;
let lastFreq=0; let lastConf=0; let allowSave=false; let smoother=new MedianSmoother(3);
let lugCount=8; let lugHz=Array(lugCount).fill(null);
let selectedLug=0; // 0-indexed

// ---- Parameters ----
let sampleRate=48000; const RING_SEC=4; // kept for compatibility
let FILTER_MODE=true; const OUTLIER_HZ=15; let histHz=[]; const HIST_N=5; let tsSmooth=null;

// ---- Onset/offset ----
let env=0, envLP=0.005; // kept for tests, not used in worklet path
const ONSET_THR=0.04;     // normalized envelope threshold
const OFFSET_THR=0.010;   // short tails OK
const MIN_HIT_MS=15;      // allow very short hits (~15ms)
const QUIET_MS_AFTER=15;  // faster tail confirm
const CONF_MIN=0.90;      // require >= 90% confidence

// ---- Drawing ----
function drawWave(timeData){ const W=waveCanvas.width=waveCanvas.clientWidth; const H=waveCanvas.height=waveCanvas.clientHeight; wctx.clearRect(0,0,W,H); wctx.lineWidth=2; wctx.beginPath(); const N=timeData.length; for(let i=0;i<N;i++){ const x=i/N*W; const y=(0.5- timeData[i]/2)*H; if(i===0) wctx.moveTo(x,y); else wctx.lineTo(x,y);} wctx.strokeStyle='#93c5fd'; wctx.stroke(); }
function drawSpectrum(freqData){ const W=specCanvas.width=specCanvas.clientWidth; const H=specCanvas.clientHeight; sctx.clearRect(0,0,W,H); sctx.fillStyle='#60a5fa'; const N=freqData.length; for(let i=0;i<N;i++){ const x=i/N*W; const v=freqData[i]/255; const h=v*H; sctx.fillRect(x, H-h, W/N, h);} }

// ---- Worklet module (inline via Blob) ----
const workletCode = `class HitSegProcessor extends AudioWorkletProcessor {\n  constructor(){\n    super();\n    this.env=0; this.envLP=0.005;\n    this.onsetThr=0.04; this.offsetThr=0.010;\n    this.minHitSamples=Math.round(0.015*sampleRate);\n    this.quietSamples=Math.round(0.015*sampleRate);\n    this.inHit=false; this.hitStart=0; this.lastAbove=0;\n    const ringSec=4; this.RING_SIZE=Math.max(8192, Math.floor(sampleRate*ringSec));\n    this.ring=new Float32Array(this.RING_SIZE); this.ringPos=0; this.total=0;\n    this.port.onmessage=(e)=>{ const c=e.data||{}; if(c.type==='config'){\n      if(typeof c.onsetThr==='number') this.onsetThr=c.onsetThr;\n      if(typeof c.offsetThr==='number') this.offsetThr=c.offsetThr;\n      if(typeof c.minHitMs==='number') this.minHitSamples=Math.max(16, Math.round(c.minHitMs/1000*sampleRate));\n      if(typeof c.quietMs==='number') this.quietSamples=Math.max(16, Math.round(c.quietMs/1000*sampleRate));\n    }};\n  }\n  process(inputs){\n    const input=inputs[0]; if(!input||input.length===0) return true; const ch=input[0];\n    for(let i=0;i<ch.length;i++){ const x=ch[i];\n      this.ring[this.ringPos]=x; this.ringPos=(this.ringPos+1)%this.RING_SIZE; this.total++;\n      this.env=(1-this.envLP)*this.env + this.envLP*Math.abs(x); const isLoud=this.env>this.onsetThr;\n      if(!this.inHit && isLoud){ this.inHit=true; this.hitStart=this.total; this.lastAbove=this.total; }\n      if(this.inHit){ if(isLoud) this.lastAbove=this.total; const since=this.total - this.lastAbove;\n        if(since>this.quietSamples && this.env<this.offsetThr){ const hitEnd=this.lastAbove; const N=hitEnd - this.hitStart; this.inHit=false;\n          if(N>=this.minHitSamples && N<this.RING_SIZE){ const buf=new Float32Array(N); for(let j=0;j<N;j++){ const idx=(this.hitStart+j)%this.RING_SIZE; buf[j]=this.ring[idx]; }\n            this.port.postMessage({type:'segment', buf:buf.buffer, sampleRate:sampleRate}, [buf.buffer]); }\n        } }\n    }\n    return true;\n  }\n}\nregisterProcessor('hit-seg-processor', HitSegProcessor);`;

// ---- Audio start/stop ----
async function startAudio(){
  if(!isSecureContextOk()){
    statusEl.textContent='HTTPSで開いてください（localhostは可）。マイクAPIは非HTTPSでは動作しません。';
    return;
  }
  try{
    setRunState(true);
    statusEl.textContent='デバイス要求中…';
    mediaStream=await navigator.mediaDevices.getUserMedia({
      audio:{
        echoCancellation:{ideal:false},
        noiseSuppression:{ideal:false},
        autoGainControl:{ideal:false}
      }
    });
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    await audioCtx.resume();
    sampleRate=audioCtx.sampleRate;

    // nodes
    source=audioCtx.createMediaStreamSource(mediaStream);
    bandpass=audioCtx.createBiquadFilter(); bandpass.type='bandpass'; bandpass.frequency.value=Number(bpFreq.value)||300; bandpass.Q.value=Number(bpQ.value)||0.707;
    softGain=audioCtx.createGain(); setGainFromDb(Number(gainDb.value)||0);
    analyser=audioCtx.createAnalyser(); analyser.fftSize=2048; const bufferLen=2048; const timeData=new Float32Array(bufferLen); const byteFreq=new Uint8Array(analyser.frequencyBinCount);

    // worklet
    const url=URL.createObjectURL(new Blob([workletCode], {type:'text/javascript'}));
    await audioCtx.audioWorklet.addModule(url);
    workletNode=new AudioWorkletNode(audioCtx, 'hit-seg-processor');
    workletNode.port.postMessage({type:'config', onsetThr:ONSET_THR, offsetThr:OFFSET_THR, minHitMs:MIN_HIT_MS, quietMs:QUIET_MS_AFTER});
    workletNode.port.onmessage= (e)=>{
      const msg=e.data||{}; if(msg.type==='segment' && msg.buf){ const seg=new Float32Array(msg.buf); analyzeSegment(seg, msg.sampleRate).then(({freq,conf})=>{ updateReadout(freq, conf); }).catch(err=>{ console.error(err); statusEl.textContent='解析エラー'; }); }
    };

    // routing: source -> bandpass -> softGain -> [analyser, worklet]
    source.connect(bandpass);
    bandpass.connect(softGain);
    softGain.connect(analyser);
    softGain.connect(workletNode);

    statusEl.textContent='計測待ち（打音検出）';

    // draw loop via analyser
    const draw=()=>{ if(!analyser) return; const timeData=new Float32Array(analyser.fftSize); const byteFreq=new Uint8Array(analyser.frequencyBinCount); analyser.getFloatTimeDomainData(timeData); drawWave(timeData); analyser.getByteFrequencyData(byteFreq); drawSpectrum(byteFreq); requestAnimationFrame(draw); };
    requestAnimationFrame(draw);
  }catch(err){
    console.error(err);
    statusEl.textContent='マイク開始に失敗：'+ (err && err.name ? err.name : '不明錯誤');
    stopAudio();
  }
}

function stopAudio(){
  try{
    if(workletNode){ try{ workletNode.port.onmessage=null; }catch(_){} try{ workletNode.disconnect(); }catch(_){} workletNode=null; }
    if(analyser){ try{ analyser.disconnect(); }catch(_){} analyser=null; }
    if(softGain){ try{ softGain.disconnect(); }catch(_){} softGain=null; }
    if(bandpass){ try{ bandpass.disconnect(); }catch(_){} bandpass=null; }
    if(source){ try{ source.disconnect(); }catch(_){} source=null; }
    if(audioCtx){ try{ audioCtx.suspend && audioCtx.suspend(); }catch(e){} try{ audioCtx.close(); }catch(e){} audioCtx=null; }
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }catch(e){ console.warn('stop error', e); }
  setRunState(false);
  saveLug.disabled = !allowSave;
  statusEl.textContent='停止中';
}

startBtn.addEventListener('click', startAudio);
stopBtn.addEventListener('click', stopAudio);

function setGainFromDb(db){ if(!softGain) return; const v=Math.pow(10, (db||0)/20); softGain.gain.value=v; gainDbVal.textContent=`${db} dB`; }

gainDb.addEventListener('input', ()=>{ setGainFromDb(Number(gainDb.value)||0); });

bpFreq.addEventListener('change', ()=>{ if(bandpass) bandpass.frequency.value=Number(bpFreq.value)||300; });
bpQ.addEventListener('change', ()=>{ if(bandpass) bandpass.Q.value=Number(bpQ.value)||0.707; });

function updateReadout(freq, conf){
  if(!(isFinite(freq)&&freq>0)) { saveLug.disabled=true; return; }
  if(conf < CONF_MIN){
    statusEl.textContent='信頼度が低いため、もう一度やり直してください（信頼度目安: 90%以上）';
    confEl.textContent = `${Math.round(conf*100)}%`;
    allowSave=false; saveLug.disabled=true; return;
  }
  let f=freq;
  if(FILTER_MODE){
    const sorted=[...histHz].sort((a,b)=>a-b); const med=sorted.length? sorted[Math.floor(sorted.length/2)] : f;
    if(Math.abs(f-med)>OUTLIER_HZ){ f=0.3*f + 0.7*med; }
    tsSmooth = (tsSmooth==null)? f : (0.5*tsSmooth + 0.5*f);
    f=tsSmooth;
    histHz.push(f); if(histHz.length>HIST_N) histHz.shift();
  }
  f = kalmanUpdateHz(f, conf);
  lastFreq=f; lastConf=conf; allowSave=true; saveLug.disabled=false;
  freqEl.textContent = `${f.toFixed(1)} Hz`;
  confEl.textContent = `${Math.round(conf*100)}%`;
  const nd=freqToNoteData(f); const cal=getCalCents(); noteEl.textContent=nd.note; centsEl.textContent=Math.round(nd.cents - cal);
  statusEl.textContent='結果更新（次の打音待ち）';
}

// ---- Analyze one segment (from worklet) ----
async function analyzeSegment(buf, sr){
  if(!buf || buf.length<128) return {freq:0, conf:0};
  const N=buf.length;
  const dropHead = Math.floor(N*0.05), dropTail=Math.floor(N*0.10);
  let s0=dropHead, s1=N-dropTail; if(s1-s0<256){ s0=0; s1=N; }
  const steady=buf.subarray(s0, s1);

  const hp=Number(hpCut.value)||60; const lp=Number(lpCut.value)||1200;
  const frame=512; const hop=128; const fft=new FFT(frame);
  const hann=new Float32Array(frame); for(let i=0;i<frame;i++){ hann[i]=0.5*(1-Math.cos(2*Math.PI*i/(frame-1))); }
  let padded=steady; if(steady.length<frame){ padded=new Float32Array(frame); padded.set(steady); }

  const frames=[]; const binHz=sr/frame; const loBin=Math.max(1, Math.floor(hp/binHz)); const hiBin=Math.min(frame/2-1, Math.ceil(lp/binHz));
  for(let off=0; off+frame<=padded.length; off+=hop){
    const x=padded.subarray(off, off+frame);
    const re=new Float64Array(frame); const im=new Float64Array(frame);
    let mean=0; for(let i=0;i<frame;i++){ mean+=x[i]; } mean/=frame; for(let i=0;i<frame;i++){ re[i]=(x[i]-mean)*hann[i]; im[i]=0; }
    fft.transform(re, im);
    const mags=new Float64Array(frame/2);
    for(let k=loBin;k<=hiBin;k++){ const a=re[k], b=im[k]; mags[k]=Math.hypot(a,b); }
    let pkBin=loBin, pkMag=0; for(let k=loBin;k<=hiBin;k++){ if(mags[k]>pkMag){ pkMag=mags[k]; pkBin=k; } }
    let delta = 0;
if(pkBin>loBin && pkBin<hiBin){ delta = quinnDeltaFromMags(mags, pkBin); }
let fPeak = (pkBin + delta) * binHz;
    const span=8; const k0=Math.max(loBin, pkBin-span), k1=Math.min(hiBin, pkBin+span); let num=0, den=0; for(let k=k0;k<=k1;k++){ const f=k*binHz; const w=mags[k]; num+=f*w; den+=w; }
    const fCentroid = den>0 ? num/den : fPeak;
    const alpha=0.7; const fEst=alpha*fPeak + (1-alpha)*fCentroid; frames.push(fEst);
  }
  if(frames.length===0) return {freq:0, conf:0};
  frames.sort((a,b)=>a-b); const cut=Math.max(0, Math.floor(frames.length*0.2)); const core=frames.slice(cut, frames.length-cut); const mean=core.reduce((a,b)=>a+b,0)/core.length; 
  const mu=mean; const sd=Math.sqrt(core.reduce((a,b)=>a+(b-mu)**2,0)/core.length); const conf = 1/ (1+ sd/ mu );
// [NEW] YIN estimate and fusion with FFT
const yin = yinPitch(steady, sr, hp, lp);
const f_fft = mean;
const conf_fft = Math.max(0, Math.min(1, conf));
let fused = f_fft;
let fusedConf = Math.max(0, Math.min(1, 0.6*conf_fft + 0.4*(yin.conf||0)));
if(Number.isFinite(yin.freq) && yin.freq>0){
  const w1 = Math.max(1e-6, conf_fft);
  const w2 = Math.max(1e-6, yin.conf||0);
  fused = (w1*f_fft + w2*yin.freq) / (w1 + w2);
  if(Math.abs(f_fft - yin.freq) > Math.max(20, 0.1*fused)){ fusedConf *= 0.8; }
}
  return {freq:fused, conf:Math.max(0, Math.min(1, fusedConf))};
}

// ---- Lugs ----
function renderLugs(){
  lugGrid.innerHTML='';
  for(let i=0;i<lugCount;i++){
    const v=lugHz[i];
    const div=document.createElement('div');
    div.className='lug'+(i===selectedLug?' selected':'');
    div.innerHTML=`<h4>ラグ ${i+1}</h4><div class="hz mono">${v? v.toFixed(1)+' Hz' : '--'}</div>`;
    div.addEventListener('click', ()=>{ selectedLug=i; renderLugs(); });
    lugGrid.appendChild(div);
  }
  const vals=lugHz.filter(v=>typeof v==='number');
  if(vals.length){
    const mean=vals.reduce((a,b)=>a+b,0)/vals.length;
    const variance=vals.reduce((a,b)=>a+(b-mean)**2,0)/vals.length; const sd=Math.sqrt(variance);
    avgHz.textContent=mean.toFixed(1); stdHz.textContent=sd.toFixed(1);
    const pct=Math.max(0, Math.min(100, (1 - Math.min(sd,15)/15)*100));
    evenBar.style.width=pct+'%';
  }else{ avgHz.textContent='--'; stdHz.textContent='--'; evenBar.style.width='0%'; }
}
renderLugs();

lugCountSel.addEventListener('change', ()=>{
  lugCount=Number(lugCountSel.value);
  selectedLug=Math.min(selectedLug, lugCount-1);
  lugHz=Array(lugCount).fill(null);
  renderLugs();
});

saveLug.addEventListener('click', ()=>{
  if(!allowSave){ statusEl.textContent='信頼度が低いため保存できません。もう一度やり直してください。'; return; }
  const idx=selectedLug;
  if(isFinite(lastFreq) && lastFreq>0){ lugHz[idx]=lastFreq; renderLugs(); }
});

clearLugs.addEventListener('click', ()=>{ lugHz=Array(lugCount).fill(null); renderLugs(); });

// ---- Self-tests ----
(function runTests(){
  const ul=document.getElementById('tests');
  function add(name, ok, info=''){
    const li=document.createElement('li');
    li.innerHTML=`<span class="${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</span> — ${name} ${info?(' <span class="muted">'+info+'</span>'):''}`;
    ul.appendChild(li);
  }
  try{
    add('DOM: startBtn exists', !!document.getElementById('startBtn'));
    add('DOM: stopBtn exists', !!document.getElementById('stopBtn'));
    add('DOM: saveLug exists', !!document.getElementById('saveLug'));

    let ok=true; try{ setRunState(true); setRunState(false); ok=true; }catch(e){ ok=false; }
    add('UI: setRunState does not throw', ok);

    const n=freqToNoteData(440).note; add('Pitch map: 440Hz → A4', n==='A4', `got ${n}`);

    const rate=44100, f=220, N=1024; const re=new Float64Array(N); const im=new Float64Array(N);
    for(let i=0;i<N;i++){ re[i]=Math.sin(2*Math.PI*f*i/rate); im[i]=0; }
    const fft=new FFT(N); fft.transform(re,im);
    let idx=0, mag=0; for(let k=1;k<N/2;k++){ const m=Math.hypot(re[k],im[k]); if(m>mag){mag=m; idx=k;} }
    const ff=idx*rate/N; add('FFT: 220Hz sine peak near 220Hz', Math.abs(ff-220)<10, `got ${ff.toFixed(1)}Hz`);

    add('Env: secure context or localhost', isSecureContextOk(), location.protocol+"//"+location.host);

    saveLug.disabled=true; allowSave=false; updateReadout(220, 0.95);
    add('Gate: saveLug enabled when conf >= 90%', !saveLug.disabled);

    saveLug.disabled=false; allowSave=true; updateReadout(220, 0.5);
    add('Gate: saveLug disabled when conf < 90%', saveLug.disabled);

    renderLugs();
    const before=document.querySelector('.lug.selected');
    const all=document.querySelectorAll('.lug');
    if(all.length>1){ all[1].click(); }
    const after=document.querySelector('.lug.selected');
    add('Lug: click changes selection', before!==after);
  }catch(e){ add('Self-test harness threw', false, e.message||String(e)); }
})();
</script>
</body>
</html>

